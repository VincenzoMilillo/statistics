<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homework 8 — Bernoulli Process vs Random Walk</title>
  <link rel="stylesheet" href="../assets/css/style-hmw6.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <header>
    <h1>Statistics & Cybersecurity</h1>
    <br>
    <nav>
      <a href="../index.html">Home</a>
      <a class="active" href="hmw7.html">Homework 9</a>
    </nav>
  </header>

  <main>
    <h2>Homework 8 — Compare Bernoulli Process with Random Walk</h2>

    <p>
      In this page we take a single probabilistic object a sequence of coin flips and look at it from
      two different perspectives:
      as a <strong>Bernoulli process</strong> that counts successes and as a <strong>random walk</strong> that
      moves up or down by one unit at each step. The key message is that these two views are
      mathematically equivalent: one keeps track of the number of \(1\)'s, the other keeps track of the
      cumulative position after \(+1/-1\) steps. This lets us reuse all binomial combinatorics to describe
      the random walk.
    </p>

    <div class="callout">
      <h3>Big picture</h3>
      <p><strong>Bernoulli process:</strong> independent trials \(X_i \in \{0,1\}\) with \(P(X_i = 1) = p\).</p>
      <p><strong>Random walk:</strong> steps \(Y_i \in \{-1,+1\}\) with \(P(Y_i = +1) = q\).</p>
      <p>
        If we define
        \[
          Y_i = 2X_i - 1 \quad\text{and take } q = p,
        \]
        then each Bernoulli success (\(X_i = 1\)) becomes a \(+1\) step and each failure (\(X_i = 0\)) becomes a \(-1\) step.
      </p>
      <p>
        The cumulative walk is
        \[
          S_n = \sum_{i=1}^n Y_i
              = \sum_{i=1}^n (2X_i - 1)
              = 2\sum_{i=1}^n X_i - n
              = 2K - n,
        \]
        where \(K = \sum_{i=1}^n X_i\) is the <strong>number of successes</strong>.
        So the distribution of \(S_n\) is just the binomial distribution of \(K\),
        transformed by the affine map \(s = 2k - n\).
      </p>
      <p>
        In other words, <strong>the random walk distribution and the binomial distribution are the same
        up to an affine transformation</strong>. All the heavy lifting is already done by the binomial formula.
      </p>
    </div>

    <div class="two-col">
      <div class="formula">
        <p><strong>Binomial link.</strong></p>
        <p>
          Let
          \[
            K = \sum_{i=1}^n X_i \sim \text{Binomial}(n,p).
          \]
          For the walk \(S_n = \sum_{i=1}^n Y_i\) with \(Y_i = 2X_i - 1\), we have the identity
          \[
            S_n = 2K - n \quad\Longleftrightarrow\quad
            K = \frac{n + S_n}{2}.
          \]
        </p>
        <p>
          Therefore, for any admissible value \(s\) (same parity as \(n\)),
          \[
            P(S_n = s)
              = P\Bigl(K = \tfrac{n+s}{2}\Bigr)
              = \binom{n}{(n+s)/2}
                p^{(n+s)/2}
                (1-p)^{(n-s)/2}.
          \]
        </p>
        <p>
          By the Law of Large Numbers,
          \[
            \frac{K}{n} \to p \quad\Rightarrow\quad
            \frac{S_n}{n}
              = 2\frac{K}{n} - 1
              \to 2p - 1.
          \]
          So the <strong>average position</strong> of the walk converges to the drift \(2p - 1\): positive if
          \(p &gt; 0.5\), negative if \(p &lt; 0.5\), and flat on average when \(p = 0.5\).
        </p>
  
        <p><strong>Pascal (Tartaglia) & binomial expansion.</strong></p>
        <p>
          The coefficients in the expansion
          \[
            (a + b)^n = \sum_{k=0}^n \binom{n}{k} a^{n-k} b^k
          \]
          are exactly the entries of row \(n\) of Pascal’s (Tartaglia’s) triangle.
        </p>
        <p>
          For a Bernoulli process (and equivalently for the random walk), the probability mass function
          \[
            P(K = k) = \binom{n}{k} p^k (1-p)^{n-k}
          \]
          uses <strong>the same coefficients</strong> \(\binom{n}{k}\): they count how many paths have exactly
          \(k\) successes and \(n-k\) failures. The probabilities \(p^k(1-p)^{n-k}\) are just the weights
          attached to each path. The triangle visualized below shows how these combinatorial weights grow with \(n\).
        </p>
      </div>
    </div>

    <h3>What this page shows and why it matters</h3>
    <div class="callout">
      <p>
        This page has three goals:
      </p>
      <p>
        <strong>1. Unify two viewpoints.</strong>
        Bernoulli sums \(K\) and random walks \(S_n\) are not two different problems; they are the same
        stochastic process seen through different lenses. This is why we can describe the walk entirely
        using binomial formulas.
      </p>
      <p>
        <strong>2. Make the combinatorics visible.</strong>
        Pascal/Tartaglia’s triangle encodes the number of ways to reach each value of \(K\).
        The binomial and random-walk histograms show how these counts become probabilities once we plug in \(p\).
      </p>
      <p>
        <strong>3. Connect with limits.</strong>
        The Law of Large Numbers tells us that empirical averages (for both \(K\) and \(S_n\)) stabilize:
        randomness does not disappear, but it becomes predictable at scale. This type of reasoning underpins
        many models in cybersecurity where repeated events (alerts, packets, log entries) are treated as
        draws from a distribution.
      </p>
    </div>

    <h3>Visual: Pascal’s triangle rows and binomial coefficients</h3>
    <div id="triangle" class="triangle"></div>
    <br>
    <div class="mini center">Rows 0…10 of Pascal/Tartaglia (hover to see values)</div>
    <br>
    <br>
    <h3>Distribution view: Binomial (K) vs. Random walk (Sₙ)</h3>
    <p>
      The first chart shows the binomial distribution of the number of successes \(K\) for \(n = 30\) and \(p = 0.35\).
      The second chart takes the same probabilities and simply re-labels the x-axis via the transformation
      \(S_n = 2K - n\). This visually confirms that the random walk’s end-point distribution is just a
      reparameterized binomial distribution.
    </p>
    <canvas id="binomChart" height="220"></canvas>
    <canvas id="walkChart" height="220"></canvas>

    <h3>Side quest: Fibonacci</h3>
    <div class="callout">
      <p>
        Counting constrained paths often yields <strong>Fibonacci</strong> numbers. For instance, the number of ways
        to reach step \(n\) using steps of size 1 or 2 satisfies the recurrence
        \[
          F_n = F_{n-1} + F_{n-2},
        \]
        because any path to \(n\) either comes from \(n-1\) (then you take a step of size 1) or from \(n-2\)
        (then you take a step of size 2).
      </p>
      <p>
        This is <em>not</em> the unconstrained \(\{-1,+1\}\) random walk studied above, but it shows how changing
        the rules of movement (allowed steps, boundaries, absorbing states) produces different recurrences and
        famous integer sequences. Random walks, binomial coefficients, and Fibonacci numbers are all variations
        on the same combinatorial theme: counting paths.
      </p>
    </div>
    <canvas id="fibChart" height="200"></canvas>

    <div class="codebox"><pre><code>// Relations
// Y_i = 2 X_i - 1        (map Bernoulli to ±1 walk)
// S_n = ∑ Y_i = 2 K - n  where K ~ Binomial(n,p)
// LLN: K/n → p  ⇒ S_n/n → 2p-1
// Pascal/Tartaglia gives the binomial coefficients that weight all paths with k successes.</code></pre></div>

  </main>

  <footer>
    <p>&copy; 2025 Vincenzo Milillo — built using HTML, CSS, JavaScript</p>
  </footer>

  <script>
    // ---- Pascal/Tartaglia small triangle (rows 0..10) ----
    function comb(n,k){
      if (k<0||k>n) return 0;
      if (k===0||k===n) return 1;
      let r=1;
      for (let i=1;i<=k;i++) r = r*(n-k+i)/i;
      return Math.round(r);
    }
    const triEl = document.getElementById('triangle');
    for (let n=0;n<=10;n++){
      const row = document.createElement('div'); row.className='row';
      for (let k=0;k<=n;k++){
        const v = comb(n,k);
        const chip = document.createElement('span');
        chip.className='chip';
        chip.title = `C(${n},${k}) = ${v}`;
        chip.textContent = v;
        row.appendChild(chip);
      }
      triEl.appendChild(row);
    }

    // ---- Binomial vs Walk distributions ----
    const n = 30, p = 0.35;
    const labelsK = Array.from({length: n+1}, (_,k)=>k);
    const probsK = labelsK.map(k => comb(n,k) * Math.pow(p,k) * Math.pow(1-p,n-k));
    const ctxB = document.getElementById('binomChart').getContext('2d');
    new Chart(ctxB, {
      type: 'bar',
      data: {
        labels: labelsK.map(String),
        datasets: [{
          label: `Binomial(n=${n}, p=${p}) on K`,
          data: probsK,
          backgroundColor: 'rgba(75,127,255,0.35)',
          borderColor: 'rgba(75,127,255,0.9)',
          borderWidth: 1.5,
          borderRadius: 6
        }]
      },
      options: {
        plugins: { legend: { labels: { color:'#e5e9f0' } } },
        scales: {
          x: { ticks: { color:'#e5e9f0', maxRotation:0 }, grid: { color:'#23272f' } },
          y: { ticks: { color:'#e5e9f0' }, grid: { color:'#23272f' }, beginAtZero:true }
        }
      }
    });

    // Map to S_n = 2K - n (only same-parity k appear)
    const labelsS = [];
    const probsS = [];
    for (let k=0;k<=n;k++){
      const s = 2*k - n;
      labelsS.push(s);
      probsS.push(probsK[k]);
    }
    const ctxW = document.getElementById('walkChart').getContext('2d');
    new Chart(ctxW, {
      type: 'bar',
      data: {
        labels: labelsS.map(String),
        datasets: [{
          label: `Random-walk Sₙ distribution (via Sₙ = 2K − n)`,
          data: probsS,
          backgroundColor: 'rgba(0,255,208,0.35)',
          borderColor: 'rgba(0,255,208,0.95)',
          borderWidth: 1.5,
          borderRadius: 6
        }]
      },
      options: {
        plugins: { legend: { labels: { color:'#e5e9f0' } } },
        scales: {
          x: { ticks: { color:'#e5e9f0', maxRotation:0 }, grid: { color:'#23272f' } },
          y: { ticks: { color:'#e5e9f0' }, grid: { color:'#23272f' }, beginAtZero:true }
        }
      }
    });

    // ---- Fibonacci quick visualization ----
    function fibArr(N){
      const a=[0,1];
      for (let i=2;i<=N;i++) a[i]=a[i-1]+a[i-2];
      return a;
    }
    const F = fibArr(14);
    const ctxF = document.getElementById('fibChart').getContext('2d');
    new Chart(ctxF, {
      type: 'line',
      data: {
        labels: F.map((_,i)=>i),
        datasets: [{
          label: 'Fibonacci F_n (n=0..14)',
          data: F,
          borderColor: 'rgba(255,193,7,0.95)',
          backgroundColor: 'rgba(255,193,7,0.25)',
          borderWidth: 2,
          tension: .15,
          pointRadius: 2
        }]
      },
      options: {
        plugins: { legend: { labels: { color:'#e5e9f0' } } },
        scales: {
          x: { ticks: { color:'#e5e9f0' }, grid: { color:'#23272f' }, title: { display:true, text:'n', color:'#e5e9f0' } },
          y: { ticks: { color:'#e5e9f0' }, grid: { color:'#23272f' }, beginAtZero:true }
        }
      }
    });
  </script>
</body>
</html>
