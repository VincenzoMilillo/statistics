<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Post 1 - Statistics & Cybersecurity</title>
  <link rel="stylesheet" href="../assets/css/style-hmw1.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],   // allow \( \) and $ $
        displayMath: [['\\[','\\]'], ['$$','$$']]
      },
      options: {
        // don’t typeset inside code/pre blocks
        skipHtmlTags: ['script','noscript','style','textarea','pre','code']
      }
    };
  </script>
  <!-- MathJax loader -->
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-okaidia.min.css">
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-sql.min.js"></script>

</head>
<body>
  <header>
    <h1>Statistics & Cybersecurity</h1>
    <br>
    <nav>
      <a href="../index.html">Home</a>
      <a href="hmw1.html" class="active">Homework 3 (todo)</a>
    </nav>
  </header>
  <main>
    <h2>Definitions: Dataset and Distribution</h2>
<p>
  <strong>Dataset.</strong> A dataset is a table where each <em>row</em> is a statistical unit (observation) and each
  <em>column</em> is a variable describing an attribute of those units. An attribute becomes a variable once a
  <em>scale</em> is set (weight in kg; <code>time_of_day</code> ∈ {morning, afternoon, evening}). Variables can be
  <em>qualitative</em> (categorical/ordinal) or <em>quantitative</em> (numeric). The data table is a matrix of units
  × variables; here we work with small k (k &lt; 3).
</p>

<p>
  <strong>Distribution.</strong> A distribution describes how the values of one or more variables are spread across the dataset.
  It is built from <em>frequencies</em> (counts) and <em>relative frequencies</em> (counts ÷ total). In descriptive statistics we
  report frequencies; in inferential statistics we model probabilities, often estimated by relative frequencies.
</p>

<h3>Univariate vs Multivariate</h3>
<p>
  <strong>Univariate distribution</strong> (1 variable): values or bins with counts/percentages.
      Examples: the frequency of <code>snack_type</code>; a histogram of numeric duration.
  <br>
  <br>
  <strong>Multivariate distribution</strong> (2+ variables): joint behavior of variables.
      <em>Bivariate</em> (2 vars) for two categoricals is shown with a contingency table; from the joint you can derive
      <em>marginals</em> and <em>conditionals</em> P(time | snack) and assess association/independence.
</p>

<h3>My dataset: what it contains and what it studies</h3>
<p>
  We collected <strong>36 observations</strong> of snack choices with <strong>k = 2 variables</strong>:
  <em>snack_type</em> ∈ {fruit, nuts, chips, yogurt, chocolate} and
  <em>time_of_day</em> ∈ {morning, afternoon, evening}.
  The goal is to describe how often each snack appears in the sample and, more broadly,
  to provide a basis for studying whether snack preferences change across the day.
  In this post we report the <strong>univariate distributions</strong> for both variables; a bivariate view can follow.
</p>
<p class="muted">
  Note: moving from the raw table to distributions removes the link to individuals, which reduces detail but preserves
  the aggregate pattern (often desirable for privacy). With small samples, nearby percentages may differ due to sampling noise.
</p>
    <h3>Snack distribution (univariate)</h3>
    <canvas id="barChart" height="180"></canvas>

    <h3>Time of day distribution (univariate)</h3>
    <canvas id="timeChart" height="180"></canvas>

    <!-- Value-label plugin: must appear BEFORE any new Chart(...) calls -->
    <script>
      // Minimal value-label plugin (prints the value above each bar)
      const valueLabelPlugin = {
        id: 'valueLabel',
        afterDatasetsDraw(chart, args, pluginOptions) {
          const { ctx } = chart;
          ctx.save();
          ctx.font = '12px JetBrains Mono, monospace';
          ctx.fillStyle = pluginOptions?.color || '#e5e9f0';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          chart.data.datasets.forEach((dataset, di) => {
            const meta = chart.getDatasetMeta(di);
            meta.data.forEach((bar, i) => {
              const value = dataset.data[i];
              const y = bar.y - 4;
              ctx.fillText(value, bar.x, y);
            });
          });
          ctx.restore();
        }
      };
    </script>

    <!-- Charts -->
    <script>
      // Data from your computed distributions (counts)
      // Snacks (casual order)
      const snackLabels = ['yogurt','chocolate','fruit','chips','nuts'];
      const snackCounts = [6, 4, 11, 7, 8];
      const snackPerc   = [16.7, 11.1, 30.6, 19.4, 22.2];

      // Time of day (ordered)
      const timeLabels = ['morning','afternoon','evening'];
      const timeCounts = [10, 13, 13];
      const timePerc   = [27.8, 36.1, 36.1];

      // Helper: tooltips show both count and percentage
      const fmt = new Intl.NumberFormat(undefined, { maximumFractionDigits: 1 });
      const tooltipBoth = (counts, perc, label) => ({
        callbacks: {
          label: (ctx) => ` ${label}: ${counts[ctx.dataIndex]} (${fmt.format(perc[ctx.dataIndex])}%)`
        }
      });

      // SNACK chart
      const snackCtx = document.getElementById('barChart').getContext('2d');
      new Chart(snackCtx, {
        type: 'bar',
        data: {
          labels: snackLabels,
          datasets: [{
            label: 'Snack frequency (n)',
            data: snackCounts,
            backgroundColor: 'rgba(0,255,208,0.35)',
            borderColor: 'rgba(0,255,208,0.9)',
            borderWidth: 2,
            borderRadius: 8
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: tooltipBoth(snackCounts, snackPerc, 'count'),
            valueLabel: { color: '#e5e9f0' } // our plugin options
          },
          scales: {
            x: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true, precision: 0 }
          }
        },
        plugins: [valueLabelPlugin] // activate custom labels
      });

      // TIME chart
      const timeCtx = document.getElementById('timeChart').getContext('2d');
      new Chart(timeCtx, {
        type: 'bar',
        data: {
          labels: timeLabels,
          datasets: [{
            label: 'Time of day frequency (n)',
            data: timeCounts,
            backgroundColor: 'rgba(0,136,255,0.30)',
            borderColor: 'rgba(0,136,255,0.9)',
            borderWidth: 2,
            borderRadius: 8
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: tooltipBoth(timeCounts, timePerc, 'count'),
            valueLabel: { color: '#e5e9f0' }
          },
          scales: {
            x: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true, precision: 0 }
          }
        },
        plugins: [valueLabelPlugin]
      });
    </script>
    <!-- End Charts -->
    <br>
    <br>
    <section id="methods">
      <h2>How I computed the univariate distributions</h2>

      <div class="callout">
        <h3>Technologies used — what and why</h3>
        <p><strong>SQLite</strong> (embedded database). It runs as a single <code>.db</code> file with no server to install.
          For a tiny assignment (k &lt; 3, a few dozen rows) this maximises portability and reproducibility compared
          to server databases (PostgreSQL) and avoids platform lock-in.</p>
        <p><strong>sqlite3 shell.</strong> Simple command-line client to execute queries and export results.</p>
        <p><strong>Chart.js.</strong> Client-side charts rendered directly in this HTML page; no backend required.</p>
        <p><strong>Static site (HTML/CSS/JS).</strong> Everything can be rebuilt locally and versioned in Git.</p>
      </div>

      <h3>SQL code used to get the output<output></output></h3>
      <div class="codebox">
          <pre><code class="language-sql">-- Univariate distribution: snack_type (counts + percentages)
        WITH total AS (SELECT COUNT(*) AS n FROM observations)
        SELECT
          snack_type,
          COUNT(*) AS count,
          ROUND(100.0 * COUNT(*) / (SELECT n FROM total), 1) AS pct
        FROM observations
        GROUP BY snack_type
        ORDER BY count DESC, snack_type;

-- Univariate distribution: time_of_day (counts + percentages)
        WITH total AS (SELECT COUNT(*) AS n FROM observations)
        SELECT
          time_of_day,
          COUNT(*) AS count,
          ROUND(100.0 * COUNT(*) / (SELECT n FROM total), 1) AS pct
        FROM observations
        GROUP BY time_of_day
        ORDER BY count DESC, time_of_day;
         </code></pre>
         <br>
        <p class="break-lines">
        -- Sample output (from sqlite3 shell):
        fruit|11|30.6
        nuts|8|22.2
        chips|7|19.4
        yogurt|6|16.7
        chocolate|4|11.1

        morning|10|27.8
        afternoon|13|36.1
        evening|13|36.1
        </p>
      </div>

      <h3>What the SQL computes (formulas)</h3>
      <div class="formula">
        <p><span class="sym">n</span> = total number of observations.</p>
        <p><span class="sym">n<sub>v</sub></span> = count of category <span class="sym">v</span> for variable <span class="sym">X</span>.</p>
        <p><strong>Absolute frequency:</strong> <code>n_v</code></p>
        <p><strong>Relative frequency:</strong> <code>f_v = n_v / n</code></p>
        <p><strong>Percentage:</strong> <code>p_v = 100 × f_v = 100 × (n_v / n)</code></p>
        <p>Example (snack_type): for <em>fruit</em>, <code>n_v = 11</code> and <code>n = 36</code> ⇒
          <code>f_v = 11/36 ≈ 0.306</code> ⇒ <code>p_v = 30.6%</code>. Same logic for <em>time_of_day</em>.</p>
      </div>
      <br>
      <br>
      <!-- ===== APPEND INSIDE YOUR EXISTING <section id="methods"> (at the end) ===== -->
      <h2>Bivariate distribution: what it represents</h2>
      <p>
        Let <code>n</code> be the total number of observations. For each snack category <code>i</code> and time-of-day
        category <code>j</code>, the bivariate (joint) distribution counts how many observations fall in that pair,
        forming a contingency table <code>n<sub>i,j</sub></code>. From the joint table you obtain marginals (each
        variable alone) and conditionals (the distribution of time given a snack).
      </p>

      <h3>SQL used to build the contingency table (counts)</h3>
      <div class="codebox">
        <pre><code class="language-sql">-- Bivariate distribution (contingency table, counts)
SELECT
  snack_type,
  SUM(CASE WHEN time_of_day='morning'   THEN 1 ELSE 0 END) AS morning,
  SUM(CASE WHEN time_of_day='afternoon' THEN 1 ELSE 0 END) AS afternoon,
  SUM(CASE WHEN time_of_day='evening'   THEN 1 ELSE 0 END) AS evening,
  COUNT(*) AS row_total
FROM observations
GROUP BY snack_type
ORDER BY snack_type;

-- Row-wise percentages: P(time | snack)
WITH ct AS (
  SELECT snack_type, time_of_day, COUNT(*) AS n
  FROM observations
  GROUP BY snack_type, time_of_day
),
row_tot AS (
  SELECT snack_type, SUM(n) AS row_n
  FROM ct GROUP BY snack_type
)
SELECT
  c.snack_type,
  ROUND(100.0 * SUM(CASE WHEN c.time_of_day='morning'   THEN c.n ELSE 0 END)/r.row_n,1) AS morning_pct,
  ROUND(100.0 * SUM(CASE WHEN c.time_of_day='afternoon' THEN c.n ELSE 0 END)/r.row_n,1) AS afternoon_pct,
  ROUND(100.0 * SUM(CASE WHEN c.time_of_day='evening'   THEN c.n ELSE 0 END)/r.row_n,1) AS evening_pct
FROM ct c
JOIN row_tot r USING (snack_type)
GROUP BY c.snack_type, r.row_n
ORDER BY c.snack_type;</code></pre>
<p class="break-lines">
-- Bivariate output (row-wise % P(time|snack))
chips|0.0|42.9|57.1
chocolate|0.0|25.0|75.0
fruit|45.5|36.4|18.2
nuts|25.0|37.5|37.5
yogurt|50.0|33.3|16.7
</p>
      </div>

      <h3>Formulas (joint, marginal, conditional)</h3>
      <div class="formula">
        <p><strong>Joint count:</strong> <code>n<sub>i,j</sub> = # { rows with snack = i and time = j }</code></p>
        <p><strong>Joint proportion:</strong> <code>p<sub>i,j</sub> = n<sub>i,j</sub> / n</code></p>
        <p><strong>Row marginal:</strong> <code>r<sub>i</sub> = Σ<sub>j</sub> n<sub>i,j</sub></code> &nbsp; (all times for snack <code>i</code>)</p>
        <p><strong>Column marginal:</strong> <code>c<sub>j</sub> = Σ<sub>i</sub> n<sub>i,j</sub></code> &nbsp; (all snacks at time <code>j</code>)</p>
        <p><strong>Row-conditional (time given snack):</strong> <code>P(time=j | snack=i) = n<sub>i,j</sub> / r<sub>i</sub></code></p>
        <p><strong>Column-conditional (snack given time):</strong> <code>P(snack=i | time=j) = n<sub>i,j</sub> / c<sub>j</sub></code></p>
      </div>
      <!-- ===== END METHODS ADDITIONS ===== -->
  </section>

  <!-- ===== BIVARIATE DISTRIBUTION (place this after your univariate charts) ===== -->
  <h3>Bivariate distribution: snack × time_of_day</h3>
  <p>
  A bivariate distribution shows how two variables occur together. In this chart, the x-axis is
  <em>time_of_day</em> and each bar is stacked by <em>snack_type</em>: the total bar height is the number of
  observations at that time, and each segment’s height is the count for that snack at that time.
  </p>
  <p class="muted">
    Read it two ways: (i) within a snack, compare its segments across bars to see when it is chosen
    (≈ conditional pattern <code>P(time | snack)</code>); (ii) within a time, compare segment sizes to see which
    snacks dominate at that time (≈ <code>P(snack | time)</code>). With small counts, percentages can be noisy—report
    counts alongside % to avoid over-interpreting.
  </p>
  <canvas id="bivarChart" height="220"></canvas>

  <!-- ===== BIVARIATE CHART DATA (replace your previous bivarChart <script> block) ===== -->
  <script>
    // Row-wise percentages P(time | snack) provided by you:
    const perc = {
      chips:     [0.0, 42.9, 57.1],
      chocolate: [0.0, 25.0, 75.0],
      fruit:     [45.5, 36.4, 18.2],
      nuts:      [25.0, 37.5, 37.5],
      yogurt:    [50.0, 33.3, 16.7],
    };

    // Counts consistent with your percentages and marginals:
    // snack totals: fruit 11, nuts 8, chips 7, yogurt 6, chocolate 4
    // time labels ordered as requested: morning, afternoon, evening
    const bivar = {
      labels: ['morning','afternoon','evening'],
      fruit:      [5, 4, 2],  // 45.5%, 36.4%, 18.2% of 11
      nuts:       [2, 3, 3],  // 25.0%, 37.5%, 37.5% of 8
      chips:      [0, 3, 4],  // 0.0%, 42.9%, 57.1% of 7
      yogurt:     [3, 2, 1],  // 50.0%, 33.3%, 16.7% of 6
      chocolate:  [0, 1, 3],  // 0.0%, 25.0%, 75.0% of 4
    };

    const bivarCtx = document.getElementById('bivarChart').getContext('2d');
    new Chart(bivarCtx, {
      type: 'bar',
      data: {
        labels: bivar.labels,
        datasets: [
          { label: 'fruit',     data: bivar.fruit,     backgroundColor: 'rgba(0,255,208,0.35)', borderColor: 'rgba(0,255,208,0.9)', borderWidth: 2, borderRadius: 6 },
          { label: 'nuts',      data: bivar.nuts,      backgroundColor: 'rgba(75,127,255,0.30)', borderColor:   'rgba(75,127,255,0.90)', borderWidth: 2, borderRadius: 6 },
          { label: 'chips',     data: bivar.chips,     backgroundColor: 'rgba(255,193,7,0.30)',  borderColor:   'rgba(255,193,7,0.90)',  borderWidth: 2, borderRadius: 6 },
          { label: 'yogurt',    data: bivar.yogurt,    backgroundColor: 'rgba(156,204,101,0.30)',borderColor:   'rgba(156,204,101,0.90)',borderWidth: 2, borderRadius: 6 },
          { label: 'chocolate', data: bivar.chocolate, backgroundColor: 'rgba(236,64,122,0.30)', borderColor:   'rgba(236,64,122,0.90)', borderWidth: 2, borderRadius: 6 },
        ]
      },
      options: {
        plugins: {
          legend: { labels: { color: '#e5e9f0' } },
          tooltip: {
            callbacks: {
              // Show count + your row-wise percentage P(time | snack)
              label: (ctx) => {
                const snack = ctx.dataset.label;
                const idx = ctx.dataIndex; // 0=morning,1=afternoon,2=evening
                const count = ctx.parsed.y;
                const p = perc[snack][idx];
                return ` ${snack}: ${count} (${p}%)`;
              }
            }
          },
          valueLabel: { color: '#e5e9f0' } // uses your existing plugin to print counts on bars
        },
        scales: {
          x: { stacked: true, ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' } },
          y: { stacked: true, ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true, precision: 0 }
        }
      },
      plugins: [valueLabelPlugin]
    });
  </script>
  <!-- ===== END BIVARIATE CHART ===== -->

  <!-- Section separator line -->
  <br>
  <br>
  <hr class="section-sep">
  <br>
  <br>
  <!-- ====== START OF PART 2 ====== -->
  <h2>Part 2 — Letter Frequency & Caesar Cipher</h2>

  <p class="lead">
    In this section we will compute the letter-frequency distribution of a chosen text, compare it to a
    language baseline, and then decrypt a Caesar-shifted text by matching frequency patterns.
  </p>

  <div class="callout">
    <h3>What we will do</h3>
    <p><strong>1.</strong> Compute the sample text letter frequency distribution.</p>
    <p><strong>2.</strong> Compare with the Italian letter frequency baseline.</p>
    <p><strong>3.</strong> Caesar Cipher: decode by comparing frequency patterns.</p>
  </div>

  <!-- Chosen text (colored by letter) -->
  <h3>1. Sample text letter frequency distribution</h3>
  <div class="textcard" id="sampleTextColored" aria-label="Sample text colored by letter"></div>

  <!-- Charts -->
  <br>
  <h3>Letter frequency — Sample text</h3>
  <canvas id="freqTextChart" height="220"></canvas>
  <br>
  <h3>2. Italian letter frequency baseline</h3>
  <canvas id="freqBaselineChart" height="220"></canvas>

  <script>

    /* Italian alphabet (21 letters): a b c d e f g h i l m n o p q r s t u v z */
    const itLetters = ['a','b','c','d','e','f','g','h','i','l','m','n','o','p','q','r','s','t','u','v','z'];
    const itSet = new Set(itLetters);

    /* Your chosen sample text (unchanged) */
    const sampleText = `I migliori inganni sono quelli in cui sembra che si lasci la scelta agli altri: le vittime sono convinte di avere il controllo della situazione, mentre in realtà sono burattini al vostro comando.
    Date agli altri alternative che si risolvano tutte a vostro vantaggio. Induceteli a scegliere il minore di due mali che servono entrambi al vostro scopo. Inchiodateli tra i corni del dilemma:
    qualsiasi cosa scelgano, non avranno scampo.`;

    /* Italian baseline (%) for the 21 letters above IN THE SAME ORDER */
    const itBaselinePct = [
      11.74, /* a */ 0.92, /* b */ 4.50, /* c */ 3.73, /* d */ 11.79, /* e */
      0.95, /* f */ 1.64, /* g */ 1.54, /* h */ 11.28, /* i */
      6.51, /* l */ 2.51, /* m */ 6.88, /* n */ 9.83, /* o */
      3.05, /* p */ 0.51, /* q */ 6.37, /* r */ 4.98, /* s */
      5.62, /* t */ 3.01, /* u */ 2.10, /* v */ 0.49  /* z */
    ];

    /* Utilities */
    function normalizeForCount(s){
      const noDiacritics = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      return noDiacritics.toLowerCase();
    }
    function countItalianLetters(s){
      const counts = Array(itLetters.length).fill(0);
      for(const ch of s){
        if (itSet.has(ch)) {
          const idx = itLetters.indexOf(ch);
          counts[idx]++;
        }
      }
      return counts;
    }
    function toPerc(counts){
      const n = counts.reduce((a,b)=>a+b,0) || 1;
      return counts.map(v => 100*v/n);
    }
    function normalizeBaseline(pct){
      const s = pct.reduce((a,b)=>a+b,0) || 1;
      return pct.map(v => 100*v/s);
    }

    /* Per-letter color map (over 21 letters, not 26) */
    function colorForLetter21(ch){
      const idx = itLetters.indexOf(ch.toLowerCase());
      if (idx === -1) return '#e5e9f0';
      const hue = (idx * 137.508) % 360; // spread nicely
      return `hsl(${hue}deg 70% 60%)`;
    }

    /* Render the colored text card (letters outside the 21-set are shown muted) */
    function renderColoredText(raw){
      const el = document.getElementById('sampleTextColored');
      const s = normalizeForCount(raw);
      const frag = document.createDocumentFragment();
      for(const ch of s){
        if (itSet.has(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'ch';
          span.style.color = colorForLetter21(ch);
          frag.appendChild(span);
        } else if (/[a-z]/.test(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;   // j k w x y and any other latin letter
          span.className = 'nonit';
          frag.appendChild(span);
        } else if (/\s/.test(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'space';
          frag.appendChild(span);
        } else {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'punct';
          frag.appendChild(span);
        }
      }
      el.innerHTML = '';
      el.appendChild(frag);
    }

    /* Charts */
    function buildTextChart(counts){
      const ctx = document.getElementById('freqTextChart').getContext('2d');
      const perc = toPerc(counts);
      const colors = itLetters.map(l => colorForLetter21(l));
      return new Chart(ctx, {
        type: 'bar',
        data: {
          labels: itLetters.map(l => l.toUpperCase()),
          datasets: [{
            label: 'Sample text (%)',
            data: perc,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 1.5,
            borderRadius: 6
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: { callbacks: { label: (c) => ` ${c.label}: ${c.parsed.y.toFixed(1)}%` } }
          },
          scales: {
            x: { ticks: { color: '#e5e9f0', maxRotation: 0 }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true }
          }
        }
      });
    }

    function buildBaselineChart(pct){
      const ctx = document.getElementById('freqBaselineChart').getContext('2d');
      const norm = normalizeBaseline(pct);
      const colors = itLetters.map(l => colorForLetter21(l));
      return new Chart(ctx, {
        type: 'bar',
        data: {
          labels: itLetters.map(l => l.toUpperCase()),
          datasets: [{
            label: 'Italian baseline (%)',
            data: norm,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 1.5,
            borderRadius: 6
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: { callbacks: { label: (c) => ` ${c.label}: ${c.parsed.y.toFixed(1)}%` } }
          },
          scales: {
            x: { ticks: { color: '#e5e9f0', maxRotation: 0 }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true }
          }
        }
      });
    }

    /* Init */
    (function(){
      renderColoredText(sampleText);
      const normalized = normalizeForCount(sampleText);
      const counts = countItalianLetters(normalized);   // counts over 21 letters only
      buildTextChart(counts);
      buildBaselineChart(itBaselinePct);
    })();
  </script>

  <br>
  <!-- Caesar cipher (random shift) ===== -->
  <h3>3. Caesar cipher (random shift & auto-decode)</h3>
  <p class="lead">
    We encrypt the sample text with a fixed shift and then recover the shift by matching the decoded
    letter frequencies to the Italian baseline.
  </p>
  <p class="metrics">
    <strong>Applied shift:</strong> <span id="shiftUsed">—</span> &nbsp;|&nbsp;
    <strong>Detected shift:</strong> <span id="shiftDetected">—</span>
  </p>

  <h4>Cipher text</h4>
  <div class="textcard" id="cipherTextColored" aria-label="Ciphered text colored by letter"></div>

  <!-- Additional part -->
  <h4>Letter frequency — Cipher text</h4>
  <canvas id="freqCipherChart" height="200"></canvas>

  <br>
  <h3>How the shift is detected</h3>
  <div class="formula">
    <p>Let <code>n</code> be total letters counted (Italian alphabet only). For each letter <code>i</code> we have:</p>
    <p><strong>Text proportion:</strong> <code>p_i = n_i / n</code> &nbsp;&nbsp;
      <strong>Baseline proportion:</strong> <code>b_i</code> (Italian)</p>
    <p>For every candidate decode shift <code>k</code> (0..20), rotate the cipher counts by <code>k</code>
      and compute a chi-square–like distance:</p>
    <p><code>score(k) = Σ_i ( (p_i - b_i)² / (b_i + 1e-9) )</code></p>
    <p>The detected shift is the <strong>argmin</strong> of <code>score(k)</code>. We then apply that shift to the
      ciphertext to obtain the decoded text.</p>
  </div>

  
  
  <h4>Distance per shift (0–20)</h4>
  <p class="break-lines" id="shiftScoresList"></p>

  <h4>Letter frequency — Auto-decoded text</h4>
  <canvas id="freqDecodedChart" height="200"></canvas>

  <script>
    /* ===== Caesar cipher over the 21-letter Italian alphabet + auto-detect ===== */

    /* We reuse itLetters, itSet, normalizeForCount, renderColoredText (already defined in your Part 2 JS) */

    /* Map letter -> index for speed */
    const itIndex = Object.fromEntries(itLetters.map((ch,i)=>[ch,i]));

    /* Shift function: only letters in the 21-letter set are shifted; others stay as-is.
      Direction: positive s encodes (plaintext -> cipher). */
    function caesarShiftItalian(raw, s){
      const sNorm = ((s % itLetters.length) + itLetters.length) % itLetters.length;
      const txt = normalizeForCount(raw); // lower + strip accents (display keeps spaces/punct as is)
      let out = '';
      for (const ch of txt) {
        if (itSet.has(ch)) {
          const i = itIndex[ch];
          const j = (i + sNorm) % itLetters.length;
          out += itLetters[j];
        } else {
          out += ch; // keep spaces/punctuation/foreign letters
        }
      }
      return out;
    }

    /* Count over the 21 letters */
    function countItalian21(s){
      const counts = Array(itLetters.length).fill(0);
      for (const ch of s) if (itSet.has(ch)) counts[itIndex[ch]]++;
      return counts;
    }

    /* Rotate counts to simulate decoding by k (cipher -> plaintext guess) */
    function rotateCountsForDecode(countsCipher, k){
      const n = itLetters.length;
      const out = Array(n).fill(0);
      // decoding by k means plaintext[i] = cipher[(i + k) mod n]
      for (let i=0;i<n;i++) out[i] = countsCipher[(i + k) % n];
      return out;
    }

    /* Convert to proportions (sum to 1) */
    function toProp(arr){
      const s = arr.reduce((a,b)=>a+b,0) || 1;
      return arr.map(v => v / s);
    }

    /* Chi-square-like distance (stable, baseline in proportions) */
    function chi2Distance(p, b){
      let s = 0;
      for (let i=0;i<p.length;i++){
        const diff = p[i] - b[i];
        s += (diff*diff) / (b[i] + 1e-9);
      }
      return s;
    }

    /* Build the score chart (distance vs shift 0..20) */
    function buildScoreChart(scores){
      const ctx = document.getElementById('scoreChart').getContext('2d');
      const labels = [...scores.keys()].map(k=>k.toString());
      const minIdx = scores.indexOf(Math.min(...scores));
      const colors = scores.map((_,i)=> i===minIdx ? 'rgba(0,255,208,0.9)' : 'rgba(75,127,255,0.5)');
      return new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Distance to Italian baseline (lower is better)',
            data: scores,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 1.5,
            borderRadius: 6
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: { callbacks: { label: (c) => ` shift ${c.label}: ${c.parsed.y.toFixed(4)}` } }
          },
          scales: {
            x: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true }
          }
        }
      });
    }

    /* Render to different targets (reuse your coloring) */
    function renderColoredTextTo(targetId, raw){
      const el = document.getElementById(targetId);
      const s = normalizeForCount(raw);
      const frag = document.createDocumentFragment();
      for(const ch of s){
        if (itSet.has(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'ch';
          span.style.color = colorForLetter21(ch);
          frag.appendChild(span);
        } else if (/[a-z]/.test(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'nonit';
          frag.appendChild(span);
        } else if (/\s/.test(ch)) {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'space';
          frag.appendChild(span);
        } else {
          const span = document.createElement('span');
          span.textContent = ch;
          span.className = 'punct';
          frag.appendChild(span);
        }
      }
      el.innerHTML = '';
      el.appendChild(frag);
    }

    /* ===== Run: encrypt with fixed shift (e.g., 18), then auto-detect ===== */
    (function(){
      const APPLIED_SHIFT = 18;                 // you asked for 18; can randomize if you want
      document.getElementById('shiftUsed').textContent = APPLIED_SHIFT.toString();

      // Encrypt
      const cipherText = caesarShiftItalian(sampleText, APPLIED_SHIFT);
      renderColoredTextTo('cipherTextColored', cipherText);

      // Count cipher letters
      const cipherCounts = countItalian21(normalizeForCount(cipherText));
      const baselineProp = toProp(normalizeBaseline(itBaselinePct)); // proportions

      // Try all decode shifts k = 0..20 and compute distance
      const scores = [];
      for (let k=0; k<itLetters.length; k++){
        const decodedCounts = rotateCountsForDecode(cipherCounts, k);
        const decodedProp = toProp(decodedCounts);
        scores.push( chi2Distance(decodedProp, baselineProp) );
      }

      // Best shift is argmin(scores). Note: this k is the decode shift applied to cipher to get plaintext.
      const bestK = scores.indexOf(Math.min(...scores));
      document.getElementById('shiftDetected').textContent = bestK.toString();

      // Build/refresh score chart
      buildScoreChart(scores);

      // Produce decoded text with the detected shift (cipher -> plaintext)
      const decodedText = caesarShiftItalian(cipherText, -bestK);
      renderColoredTextTo('decodedTextColored', decodedText);
    })();
  </script>

  <script>
    // === EXTRA JS: build charts for cipher & decoded + show scores ===

    // Reuse colorForLetter21 and itLetters already defined
    function buildFreqChart(canvasId, counts, label){
      const ctx = document.getElementById(canvasId).getContext('2d');
      const perc = (function toPerc(counts){
        const n = counts.reduce((a,b)=>a+b,0) || 1;
        return counts.map(v => 100*v/n);
      })(counts);
      const colors = itLetters.map(l => colorForLetter21(l));
      return new Chart(ctx, {
        type: 'bar',
        data: {
          labels: itLetters.map(l => l.toUpperCase()),
          datasets: [{
            label,
            data: perc,
            backgroundColor: colors,
            borderColor: colors,
            borderWidth: 1.5,
            borderRadius: 6
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#e5e9f0' } },
            tooltip: { callbacks: { label: (c) => ` ${c.label}: ${c.parsed.y.toFixed(1)}%` } }
          },
          scales: {
            x: { ticks: { color: '#e5e9f0', maxRotation: 0 }, grid: { color: '#23272f' } },
            y: { ticks: { color: '#e5e9f0' }, grid: { color: '#23272f' }, beginAtZero: true }
          }
        }
      });
    }

    // Hook into the Caesar block you already added:
    (function(){
      // If these variables/functions exist from your previous script, we reuse them:
      if (typeof itLetters === 'undefined') return;

      // Read already-rendered cipher/decoded texts if present; otherwise recompute quickly:
      const cipherNode = document.getElementById('cipherTextColored');
      const decodedNode = document.getElementById('decodedTextColored');

      // We need the same counts/scores computed in your Caesar script.
      // If you kept variable names, reuse them; otherwise recompute here:

      // Pull plaintext from the earlier constant (sampleText) and re-run minimal Caesar flow:
      const APPLIED_SHIFT = Number(document.getElementById('shiftUsed')?.textContent) || 18;

      // Minimal helpers (shadowing to be safe)
      const itSetLocal = new Set(itLetters);
      const itIndexLocal = Object.fromEntries(itLetters.map((ch,i)=>[ch,i]));

      function normalizeForCountLocal(s){
        return s.normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
      }
      function caesarShiftItalianLocal(raw, s){
        const n = itLetters.length;
        const sNorm = ((s % n) + n) % n;
        const txt = normalizeForCountLocal(raw);
        let out = '';
        for (const ch of txt){
          if (itSetLocal.has(ch)){
            const j = (itIndexLocal[ch] + sNorm) % n;
            out += itLetters[j];
          } else {
            out += ch;
          }
        }
        return out;
      }
      function countItalian21Local(s){
        const counts = Array(itLetters.length).fill(0);
        for (const ch of s) if (itSetLocal.has(ch)) counts[itIndexLocal[ch]]++;
        return counts;
      }
      function rotateCountsForDecodeLocal(countsCipher, k){
        const n = itLetters.length, out = Array(n).fill(0);
        for (let i=0;i<n;i++) out[i] = countsCipher[(i + k) % n];
        return out;
      }
      function toPropLocal(arr){ const t = arr.reduce((a,b)=>a+b,0)||1; return arr.map(v=>v/t); }
      function normalizeBaselineLocal(pct){ const s=pct.reduce((a,b)=>a+b,0)||1; return pct.map(v=>v/s); }
      function chi2DistanceLocal(p, b){
        let s = 0; for (let i=0;i<p.length;i++){ const d=p[i]-b[i]; s += (d*d)/(b[i]+1e-9); } return s;
      }

      // Rebuild cipher/decoded to ensure we have counts here:
      const cipherText = caesarShiftItalianLocal(sampleText, APPLIED_SHIFT);
      const decodedShift = Number(document.getElementById('shiftDetected')?.textContent) || 0;
      const decodedText = caesarShiftItalianLocal(cipherText, -decodedShift);

      const cipherCounts = countItalian21Local(normalizeForCountLocal(cipherText));
      const decodedCounts = countItalian21Local(normalizeForCountLocal(decodedText));

      // Render the two frequency charts
      buildFreqChart('freqCipherChart',  cipherCounts,  'Cipher (%)');
      buildFreqChart('freqDecodedChart', decodedCounts, 'Decoded (%)');

      // Recompute and list scores neatly
      const baselineProp = toPropLocal(normalizeBaselineLocal(itBaselinePct));
      const scores = [];
      for (let k=0; k<itLetters.length; k++){
        const dec = rotateCountsForDecodeLocal(cipherCounts, k);
        scores.push( chi2DistanceLocal(toPropLocal(dec), baselineProp) );
      }
      const bestK = scores.indexOf(Math.min(...scores));
      const lines = scores.map((v,i)=> (i===bestK ? `→ ${i}: ${v.toFixed(6)}  (min)` : `  ${i}: ${v.toFixed(6)}`));
      document.getElementById('shiftScoresList').textContent =
        `score(k) = Σ_i ( (p_i - b_i)^2 / (b_i + 1e-9) )\n` +
        lines.join('\n');
    })();
  </script>

  <br>
  <h3>Decrypted text (invert shift by 18)</h3>
  <div class="textcard" id="decodedShift18Colored" aria-label="Decoded text colored by letter"></div>
  <script>
    (function(){
      const exists = document.getElementById('decodedShift18Colored');
      if (!exists) return;
      let textToDecrypt;
      if (typeof cipherText === 'string') {
        textToDecrypt = cipherText;
      } else if (typeof sampleText === 'string') {
        textToDecrypt = caesarShiftItalian(sampleText, 18);
      } else {
        return;
      }
      const decodedBy18 = caesarShiftItalian(textToDecrypt, -18);
      renderColoredTextTo('decodedShift18Colored', decodedBy18);
    })();
  </script>
  <br>
  
  <h3>Summary</h3>
  <p id="finalComment" class="note"></p>
  <script>
    (function(){
      const used = document.getElementById('shiftUsed')?.textContent || '—';
      const detected = document.getElementById('shiftDetected')?.textContent || '—';
      const el = document.getElementById('finalComment');
      if (!el) return;
      el.textContent =
        `The sample’s letter distribution broadly matches the Italian baseline with expected deviations from style and length. After encrypting with a Caesar shift of ${used}, the frequency-matching decoder selected shift ${detected}, recovering the plaintext. The distance-by-shift scores and the cipher/decoded frequency charts are consistent with this result. Limitations: short texts and topic-specific vocabulary can bias frequencies; we normalize diacritics and restrict to the 21-letter Italian alphabet.`;
    })();
  </script>

  <!-- ===== END PART 2 STRUCTURE ===== -->
  </main>
  <footer>
    <p>&copy; 2025 Vincenzo Milillo — built using HTML, CSS, JavaScript</p>
  </footer>
</body>
</html>